// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.10.0.

// ignore_for_file: unused_import, unused_element, unnecessary_import, duplicate_ignore, invalid_use_of_internal_member, annotate_overrides, non_constant_identifier_names, curly_braces_in_flow_control_structures, prefer_const_literals_to_create_immutables, unused_field

import 'algorithms/bnb.dart';
import 'algorithms/fifo.dart';
import 'algorithms/knapsack.dart';
import 'algorithms/lowestlarger.dart';
import 'algorithms/srd.dart';
import 'dart:async';
import 'dart:convert';
import 'frb_generated.dart';
import 'frb_generated.io.dart'
    if (dart.library.js_interop) 'frb_generated.web.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'selectcoin.dart';
import 'types.dart';
import 'utils.dart';

/// Main entrypoint of the Rust API
class RustLib extends BaseEntrypoint<RustLibApi, RustLibApiImpl, RustLibWire> {
  @internal
  static final instance = RustLib._();

  RustLib._();

  /// Initialize flutter_rust_bridge
  static Future<void> init({
    RustLibApi? api,
    BaseHandler? handler,
    ExternalLibrary? externalLibrary,
  }) async {
    await instance.initImpl(
      api: api,
      handler: handler,
      externalLibrary: externalLibrary,
    );
  }

  /// Initialize flutter_rust_bridge in mock mode.
  /// No libraries for FFI are loaded.
  static void initMock({required RustLibApi api}) {
    instance.initMockImpl(api: api);
  }

  /// Dispose flutter_rust_bridge
  ///
  /// The call to this function is optional, since flutter_rust_bridge (and everything else)
  /// is automatically disposed when the app stops.
  static void dispose() => instance.disposeImpl();

  @override
  ApiImplConstructor<RustLibApiImpl, RustLibWire> get apiImplConstructor =>
      RustLibApiImpl.new;

  @override
  WireConstructor<RustLibWire> get wireConstructor =>
      RustLibWire.fromExternalLibrary;

  @override
  Future<void> executeRustInitializers() async {}

  @override
  ExternalLibraryLoaderConfig get defaultExternalLibraryLoaderConfig =>
      kDefaultExternalLibraryLoaderConfig;

  @override
  String get codegenVersion => '2.10.0';

  @override
  int get rustContentHash => -1367582125;

  static const kDefaultExternalLibraryLoaderConfig =
      ExternalLibraryLoaderConfig(
        stem: 'rust_coinselect',
        ioDirectory: 'rust-coinselect/target/release/',
        webPrefix: 'pkg/',
      );
}

abstract class RustLibApi extends BaseApi {
  Future<BigInt> crateUtilsCalculateAccumulatedWeight({
    required List<(BigInt, BigInt, BigInt)> smallerCoins,
    required Set<BigInt> selectedInputs,
  });

  Future<BigInt> crateUtilsCalculateBaseWeightBtc({
    required BigInt outputWeight,
  });

  Future<BigInt> crateUtilsCalculateFee({
    required BigInt weight,
    required double rate,
  });

  Future<BigInt> crateUtilsCalculateWaste({
    required CoinSelectionOpt options,
    required BigInt accumulatedValue,
    required BigInt accumulatedWeight,
    required BigInt estimatedFee,
  });

  Future<BigInt> crateUtilsEffectiveValue({
    required OutputGroup output,
    required double feerate,
  });

  Future<SelectionOutput> crateSelectcoinSelectCoin({
    required List<OutputGroup> inputs,
    required CoinSelectionOpt options,
  });

  Future<SelectionOutput> crateAlgorithmsBnbSelectCoinBnb({
    required List<OutputGroup> inputs,
    required CoinSelectionOpt options,
  });

  Future<SelectionOutput> crateAlgorithmsFifoSelectCoinFifo({
    required List<OutputGroup> inputs,
    required CoinSelectionOpt options,
  });

  Future<SelectionOutput> crateAlgorithmsKnapsackSelectCoinKnapsack({
    required List<OutputGroup> inputs,
    required CoinSelectionOpt options,
  });

  Future<SelectionOutput> crateAlgorithmsLowestlargerSelectCoinLowestlarger({
    required List<OutputGroup> inputs,
    required CoinSelectionOpt options,
  });

  Future<SelectionOutput> crateAlgorithmsSrdSelectCoinSrd({
    required List<OutputGroup> inputs,
    required CoinSelectionOpt options,
  });
}

class RustLibApiImpl extends RustLibApiImplPlatform implements RustLibApi {
  RustLibApiImpl({
    required super.handler,
    required super.wire,
    required super.generalizedFrbRustBinding,
    required super.portManager,
  });

  @override
  Future<BigInt> crateUtilsCalculateAccumulatedWeight({
    required List<(BigInt, BigInt, BigInt)> smallerCoins,
    required Set<BigInt> selectedInputs,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_list_record_usize_u_64_u_64(smallerCoins, serializer);
          sse_encode_Set_usize_None(selectedInputs, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 1,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_u_64,
          decodeErrorData: null,
        ),
        constMeta: kCrateUtilsCalculateAccumulatedWeightConstMeta,
        argValues: [smallerCoins, selectedInputs],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateUtilsCalculateAccumulatedWeightConstMeta =>
      const TaskConstMeta(
        debugName: "calculate_accumulated_weight",
        argNames: ["smallerCoins", "selectedInputs"],
      );

  @override
  Future<BigInt> crateUtilsCalculateBaseWeightBtc({
    required BigInt outputWeight,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_u_64(outputWeight, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 2,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_u_64,
          decodeErrorData: null,
        ),
        constMeta: kCrateUtilsCalculateBaseWeightBtcConstMeta,
        argValues: [outputWeight],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateUtilsCalculateBaseWeightBtcConstMeta =>
      const TaskConstMeta(
        debugName: "calculate_base_weight_btc",
        argNames: ["outputWeight"],
      );

  @override
  Future<BigInt> crateUtilsCalculateFee({
    required BigInt weight,
    required double rate,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_u_64(weight, serializer);
          sse_encode_f_32(rate, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 3,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_u_64,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateUtilsCalculateFeeConstMeta,
        argValues: [weight, rate],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateUtilsCalculateFeeConstMeta => const TaskConstMeta(
    debugName: "calculate_fee",
    argNames: ["weight", "rate"],
  );

  @override
  Future<BigInt> crateUtilsCalculateWaste({
    required CoinSelectionOpt options,
    required BigInt accumulatedValue,
    required BigInt accumulatedWeight,
    required BigInt estimatedFee,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_box_autoadd_coin_selection_opt(options, serializer);
          sse_encode_u_64(accumulatedValue, serializer);
          sse_encode_u_64(accumulatedWeight, serializer);
          sse_encode_u_64(estimatedFee, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 4,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_u_64,
          decodeErrorData: null,
        ),
        constMeta: kCrateUtilsCalculateWasteConstMeta,
        argValues: [options, accumulatedValue, accumulatedWeight, estimatedFee],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateUtilsCalculateWasteConstMeta => const TaskConstMeta(
    debugName: "calculate_waste",
    argNames: [
      "options",
      "accumulatedValue",
      "accumulatedWeight",
      "estimatedFee",
    ],
  );

  @override
  Future<BigInt> crateUtilsEffectiveValue({
    required OutputGroup output,
    required double feerate,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_box_autoadd_output_group(output, serializer);
          sse_encode_f_32(feerate, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 5,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_u_64,
          decodeErrorData: sse_decode_AnyhowException,
        ),
        constMeta: kCrateUtilsEffectiveValueConstMeta,
        argValues: [output, feerate],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateUtilsEffectiveValueConstMeta => const TaskConstMeta(
    debugName: "effective_value",
    argNames: ["output", "feerate"],
  );

  @override
  Future<SelectionOutput> crateSelectcoinSelectCoin({
    required List<OutputGroup> inputs,
    required CoinSelectionOpt options,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_list_output_group(inputs, serializer);
          sse_encode_box_autoadd_coin_selection_opt(options, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 6,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_selection_output,
          decodeErrorData: sse_decode_selection_error,
        ),
        constMeta: kCrateSelectcoinSelectCoinConstMeta,
        argValues: [inputs, options],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateSelectcoinSelectCoinConstMeta => const TaskConstMeta(
    debugName: "select_coin",
    argNames: ["inputs", "options"],
  );

  @override
  Future<SelectionOutput> crateAlgorithmsBnbSelectCoinBnb({
    required List<OutputGroup> inputs,
    required CoinSelectionOpt options,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_list_output_group(inputs, serializer);
          sse_encode_box_autoadd_coin_selection_opt(options, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 7,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_selection_output,
          decodeErrorData: sse_decode_selection_error,
        ),
        constMeta: kCrateAlgorithmsBnbSelectCoinBnbConstMeta,
        argValues: [inputs, options],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateAlgorithmsBnbSelectCoinBnbConstMeta =>
      const TaskConstMeta(
        debugName: "select_coin_bnb",
        argNames: ["inputs", "options"],
      );

  @override
  Future<SelectionOutput> crateAlgorithmsFifoSelectCoinFifo({
    required List<OutputGroup> inputs,
    required CoinSelectionOpt options,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_list_output_group(inputs, serializer);
          sse_encode_box_autoadd_coin_selection_opt(options, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 8,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_selection_output,
          decodeErrorData: sse_decode_selection_error,
        ),
        constMeta: kCrateAlgorithmsFifoSelectCoinFifoConstMeta,
        argValues: [inputs, options],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateAlgorithmsFifoSelectCoinFifoConstMeta =>
      const TaskConstMeta(
        debugName: "select_coin_fifo",
        argNames: ["inputs", "options"],
      );

  @override
  Future<SelectionOutput> crateAlgorithmsKnapsackSelectCoinKnapsack({
    required List<OutputGroup> inputs,
    required CoinSelectionOpt options,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_list_output_group(inputs, serializer);
          sse_encode_box_autoadd_coin_selection_opt(options, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 9,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_selection_output,
          decodeErrorData: sse_decode_selection_error,
        ),
        constMeta: kCrateAlgorithmsKnapsackSelectCoinKnapsackConstMeta,
        argValues: [inputs, options],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateAlgorithmsKnapsackSelectCoinKnapsackConstMeta =>
      const TaskConstMeta(
        debugName: "select_coin_knapsack",
        argNames: ["inputs", "options"],
      );

  @override
  Future<SelectionOutput> crateAlgorithmsLowestlargerSelectCoinLowestlarger({
    required List<OutputGroup> inputs,
    required CoinSelectionOpt options,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_list_output_group(inputs, serializer);
          sse_encode_box_autoadd_coin_selection_opt(options, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 10,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_selection_output,
          decodeErrorData: sse_decode_selection_error,
        ),
        constMeta: kCrateAlgorithmsLowestlargerSelectCoinLowestlargerConstMeta,
        argValues: [inputs, options],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta
  get kCrateAlgorithmsLowestlargerSelectCoinLowestlargerConstMeta =>
      const TaskConstMeta(
        debugName: "select_coin_lowestlarger",
        argNames: ["inputs", "options"],
      );

  @override
  Future<SelectionOutput> crateAlgorithmsSrdSelectCoinSrd({
    required List<OutputGroup> inputs,
    required CoinSelectionOpt options,
  }) {
    return handler.executeNormal(
      NormalTask(
        callFfi: (port_) {
          final serializer = SseSerializer(generalizedFrbRustBinding);
          sse_encode_list_output_group(inputs, serializer);
          sse_encode_box_autoadd_coin_selection_opt(options, serializer);
          pdeCallFfi(
            generalizedFrbRustBinding,
            serializer,
            funcId: 11,
            port: port_,
          );
        },
        codec: SseCodec(
          decodeSuccessData: sse_decode_selection_output,
          decodeErrorData: sse_decode_selection_error,
        ),
        constMeta: kCrateAlgorithmsSrdSelectCoinSrdConstMeta,
        argValues: [inputs, options],
        apiImpl: this,
      ),
    );
  }

  TaskConstMeta get kCrateAlgorithmsSrdSelectCoinSrdConstMeta =>
      const TaskConstMeta(
        debugName: "select_coin_srd",
        argNames: ["inputs", "options"],
      );

  @protected
  AnyhowException dco_decode_AnyhowException(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return AnyhowException(raw as String);
  }

  @protected
  Set<BigInt> dco_decode_Set_usize_None(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return Set.from(dco_decode_list_prim_usize_strict(raw));
  }

  @protected
  String dco_decode_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as String;
  }

  @protected
  CoinSelectionOpt dco_decode_box_autoadd_coin_selection_opt(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_coin_selection_opt(raw);
  }

  @protected
  double dco_decode_box_autoadd_f_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as double;
  }

  @protected
  OutputGroup dco_decode_box_autoadd_output_group(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_output_group(raw);
  }

  @protected
  int dco_decode_box_autoadd_u_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  CoinSelectionOpt dco_decode_coin_selection_opt(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 11)
      throw Exception('unexpected arr length: expect 11 but see ${arr.length}');
    return CoinSelectionOpt(
      targetValue: dco_decode_u_64(arr[0]),
      targetFeerate: dco_decode_f_32(arr[1]),
      longTermFeerate: dco_decode_opt_box_autoadd_f_32(arr[2]),
      minAbsoluteFee: dco_decode_u_64(arr[3]),
      baseWeight: dco_decode_u_64(arr[4]),
      changeWeight: dco_decode_u_64(arr[5]),
      changeCost: dco_decode_u_64(arr[6]),
      avgInputWeight: dco_decode_u_64(arr[7]),
      avgOutputWeight: dco_decode_u_64(arr[8]),
      minChangeValue: dco_decode_u_64(arr[9]),
      excessStrategy: dco_decode_excess_strategy(arr[10]),
    );
  }

  @protected
  ExcessStrategy dco_decode_excess_strategy(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ExcessStrategy.values[raw as int];
  }

  @protected
  double dco_decode_f_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as double;
  }

  @protected
  int dco_decode_i_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  List<OutputGroup> dco_decode_list_output_group(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_output_group).toList();
  }

  @protected
  Uint8List dco_decode_list_prim_u_8_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as Uint8List;
  }

  @protected
  Uint64List dco_decode_list_prim_usize_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as Uint64List;
  }

  @protected
  List<(BigInt, BigInt, BigInt)> dco_decode_list_record_usize_u_64_u_64(
    dynamic raw,
  ) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>)
        .map(dco_decode_record_usize_u_64_u_64)
        .toList();
  }

  @protected
  double? dco_decode_opt_box_autoadd_f_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_f_32(raw);
  }

  @protected
  int? dco_decode_opt_box_autoadd_u_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_u_32(raw);
  }

  @protected
  OutputGroup dco_decode_output_group(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return OutputGroup(
      value: dco_decode_u_64(arr[0]),
      weight: dco_decode_u_64(arr[1]),
      inputCount: dco_decode_usize(arr[2]),
      creationSequence: dco_decode_opt_box_autoadd_u_32(arr[3]),
    );
  }

  @protected
  (BigInt, BigInt, BigInt) dco_decode_record_usize_u_64_u_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3) {
      throw Exception('Expected 3 elements, got ${arr.length}');
    }
    return (
      dco_decode_usize(arr[0]),
      dco_decode_u_64(arr[1]),
      dco_decode_u_64(arr[2]),
    );
  }

  @protected
  SelectionError dco_decode_selection_error(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return SelectionError.values[raw as int];
  }

  @protected
  SelectionOutput dco_decode_selection_output(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return SelectionOutput(
      selectedInputs: dco_decode_list_prim_usize_strict(arr[0]),
      waste: dco_decode_waste_metric(arr[1]),
    );
  }

  @protected
  int dco_decode_u_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  BigInt dco_decode_u_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeU64(raw);
  }

  @protected
  int dco_decode_u_8(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  void dco_decode_unit(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return;
  }

  @protected
  BigInt dco_decode_usize(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeU64(raw);
  }

  @protected
  WasteMetric dco_decode_waste_metric(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return WasteMetric(field0: dco_decode_u_64(arr[0]));
  }

  @protected
  AnyhowException sse_decode_AnyhowException(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_String(deserializer);
    return AnyhowException(inner);
  }

  @protected
  Set<BigInt> sse_decode_Set_usize_None(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_list_prim_usize_strict(deserializer);
    return Set.from(inner);
  }

  @protected
  String sse_decode_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_list_prim_u_8_strict(deserializer);
    return utf8.decoder.convert(inner);
  }

  @protected
  CoinSelectionOpt sse_decode_box_autoadd_coin_selection_opt(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_coin_selection_opt(deserializer));
  }

  @protected
  double sse_decode_box_autoadd_f_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_f_32(deserializer));
  }

  @protected
  OutputGroup sse_decode_box_autoadd_output_group(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_output_group(deserializer));
  }

  @protected
  int sse_decode_box_autoadd_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_u_32(deserializer));
  }

  @protected
  CoinSelectionOpt sse_decode_coin_selection_opt(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_targetValue = sse_decode_u_64(deserializer);
    var var_targetFeerate = sse_decode_f_32(deserializer);
    var var_longTermFeerate = sse_decode_opt_box_autoadd_f_32(deserializer);
    var var_minAbsoluteFee = sse_decode_u_64(deserializer);
    var var_baseWeight = sse_decode_u_64(deserializer);
    var var_changeWeight = sse_decode_u_64(deserializer);
    var var_changeCost = sse_decode_u_64(deserializer);
    var var_avgInputWeight = sse_decode_u_64(deserializer);
    var var_avgOutputWeight = sse_decode_u_64(deserializer);
    var var_minChangeValue = sse_decode_u_64(deserializer);
    var var_excessStrategy = sse_decode_excess_strategy(deserializer);
    return CoinSelectionOpt(
      targetValue: var_targetValue,
      targetFeerate: var_targetFeerate,
      longTermFeerate: var_longTermFeerate,
      minAbsoluteFee: var_minAbsoluteFee,
      baseWeight: var_baseWeight,
      changeWeight: var_changeWeight,
      changeCost: var_changeCost,
      avgInputWeight: var_avgInputWeight,
      avgOutputWeight: var_avgOutputWeight,
      minChangeValue: var_minChangeValue,
      excessStrategy: var_excessStrategy,
    );
  }

  @protected
  ExcessStrategy sse_decode_excess_strategy(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return ExcessStrategy.values[inner];
  }

  @protected
  double sse_decode_f_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getFloat32();
  }

  @protected
  int sse_decode_i_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getInt32();
  }

  @protected
  List<OutputGroup> sse_decode_list_output_group(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <OutputGroup>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_output_group(deserializer));
    }
    return ans_;
  }

  @protected
  Uint8List sse_decode_list_prim_u_8_strict(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getUint8List(len_);
  }

  @protected
  Uint64List sse_decode_list_prim_usize_strict(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getUint64List(len_);
  }

  @protected
  List<(BigInt, BigInt, BigInt)> sse_decode_list_record_usize_u_64_u_64(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <(BigInt, BigInt, BigInt)>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_record_usize_u_64_u_64(deserializer));
    }
    return ans_;
  }

  @protected
  double? sse_decode_opt_box_autoadd_f_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_f_32(deserializer));
    } else {
      return null;
    }
  }

  @protected
  int? sse_decode_opt_box_autoadd_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_u_32(deserializer));
    } else {
      return null;
    }
  }

  @protected
  OutputGroup sse_decode_output_group(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_value = sse_decode_u_64(deserializer);
    var var_weight = sse_decode_u_64(deserializer);
    var var_inputCount = sse_decode_usize(deserializer);
    var var_creationSequence = sse_decode_opt_box_autoadd_u_32(deserializer);
    return OutputGroup(
      value: var_value,
      weight: var_weight,
      inputCount: var_inputCount,
      creationSequence: var_creationSequence,
    );
  }

  @protected
  (BigInt, BigInt, BigInt) sse_decode_record_usize_u_64_u_64(
    SseDeserializer deserializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_field0 = sse_decode_usize(deserializer);
    var var_field1 = sse_decode_u_64(deserializer);
    var var_field2 = sse_decode_u_64(deserializer);
    return (var_field0, var_field1, var_field2);
  }

  @protected
  SelectionError sse_decode_selection_error(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return SelectionError.values[inner];
  }

  @protected
  SelectionOutput sse_decode_selection_output(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_selectedInputs = sse_decode_list_prim_usize_strict(deserializer);
    var var_waste = sse_decode_waste_metric(deserializer);
    return SelectionOutput(
      selectedInputs: var_selectedInputs,
      waste: var_waste,
    );
  }

  @protected
  int sse_decode_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint32();
  }

  @protected
  BigInt sse_decode_u_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getBigUint64();
  }

  @protected
  int sse_decode_u_8(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8();
  }

  @protected
  void sse_decode_unit(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  BigInt sse_decode_usize(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getBigUint64();
  }

  @protected
  WasteMetric sse_decode_waste_metric(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_field0 = sse_decode_u_64(deserializer);
    return WasteMetric(field0: var_field0);
  }

  @protected
  bool sse_decode_bool(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8() != 0;
  }

  @protected
  void sse_encode_AnyhowException(
    AnyhowException self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.message, serializer);
  }

  @protected
  void sse_encode_Set_usize_None(Set<BigInt> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_usize_strict(
      Uint64List.fromList(self.toList()),
      serializer,
    );
  }

  @protected
  void sse_encode_String(String self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(utf8.encoder.convert(self), serializer);
  }

  @protected
  void sse_encode_box_autoadd_coin_selection_opt(
    CoinSelectionOpt self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_coin_selection_opt(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_f_32(double self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_f_32(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_output_group(
    OutputGroup self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_output_group(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_u_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_32(self, serializer);
  }

  @protected
  void sse_encode_coin_selection_opt(
    CoinSelectionOpt self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_64(self.targetValue, serializer);
    sse_encode_f_32(self.targetFeerate, serializer);
    sse_encode_opt_box_autoadd_f_32(self.longTermFeerate, serializer);
    sse_encode_u_64(self.minAbsoluteFee, serializer);
    sse_encode_u_64(self.baseWeight, serializer);
    sse_encode_u_64(self.changeWeight, serializer);
    sse_encode_u_64(self.changeCost, serializer);
    sse_encode_u_64(self.avgInputWeight, serializer);
    sse_encode_u_64(self.avgOutputWeight, serializer);
    sse_encode_u_64(self.minChangeValue, serializer);
    sse_encode_excess_strategy(self.excessStrategy, serializer);
  }

  @protected
  void sse_encode_excess_strategy(
    ExcessStrategy self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_f_32(double self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putFloat32(self);
  }

  @protected
  void sse_encode_i_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putInt32(self);
  }

  @protected
  void sse_encode_list_output_group(
    List<OutputGroup> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_output_group(item, serializer);
    }
  }

  @protected
  void sse_encode_list_prim_u_8_strict(
    Uint8List self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer.putUint8List(self);
  }

  @protected
  void sse_encode_list_prim_usize_strict(
    Uint64List self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer.putUint64List(self);
  }

  @protected
  void sse_encode_list_record_usize_u_64_u_64(
    List<(BigInt, BigInt, BigInt)> self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_record_usize_u_64_u_64(item, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_f_32(double? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_f_32(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_u_32(int? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_u_32(self, serializer);
    }
  }

  @protected
  void sse_encode_output_group(OutputGroup self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_64(self.value, serializer);
    sse_encode_u_64(self.weight, serializer);
    sse_encode_usize(self.inputCount, serializer);
    sse_encode_opt_box_autoadd_u_32(self.creationSequence, serializer);
  }

  @protected
  void sse_encode_record_usize_u_64_u_64(
    (BigInt, BigInt, BigInt) self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.$1, serializer);
    sse_encode_u_64(self.$2, serializer);
    sse_encode_u_64(self.$3, serializer);
  }

  @protected
  void sse_encode_selection_error(
    SelectionError self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_selection_output(
    SelectionOutput self,
    SseSerializer serializer,
  ) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_usize_strict(self.selectedInputs, serializer);
    sse_encode_waste_metric(self.waste, serializer);
  }

  @protected
  void sse_encode_u_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint32(self);
  }

  @protected
  void sse_encode_u_64(BigInt self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putBigUint64(self);
  }

  @protected
  void sse_encode_u_8(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self);
  }

  @protected
  void sse_encode_unit(void self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  void sse_encode_usize(BigInt self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putBigUint64(self);
  }

  @protected
  void sse_encode_waste_metric(WasteMetric self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_64(self.field0, serializer);
  }

  @protected
  void sse_encode_bool(bool self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self ? 1 : 0);
  }
}
